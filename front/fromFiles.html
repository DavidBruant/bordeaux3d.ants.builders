<!doctype html>
<html lang="en">
<head>
  <title>Treehouse Logo in three.js</title>
  <meta charset="utf-8">
</head>
<body style="margin: 0;">

<input class='hour' type='range' value='0' min='0' max='23'></input>
    <input class='season' type='checkbox'></input> winter<br/>
    <span class='current-hour'></span>
    <br/>

  <script src="js/ext/three.js"></script>
  <script src="js/ext/OrbitControls.js"></script>
  <script src="js/ext/jquery-1.11.1.min.js"></script>
  <script src="js/SunPosition.js"></script>

  <script>

    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer;

    // global variables for time
    var curHour = 10;
    var seasonsMonth = [7, 11];
    var curMonth = seasonsMonth[0];

    init();
    animate();

    // Sets up the scene.
    function init() {

      // Create the scene and set the scene size.
      scene = new THREE.Scene();

      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      // Create a renderer and add it to the DOM.
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(WIDTH, HEIGHT);
      renderer.shadowMapEnabled = true;
      renderer.shadowMapSoft = true;
      document.body.appendChild(renderer.domElement);


      // Create an event listener that resizes the renderer with the browser window.
      window.addEventListener('resize', function() {
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
      });

      // Set the background color of the scene.
      renderer.setClearColorHex(0x333F47, 1);
      

      // go through tiles
      var myRegexp = /x(\d+)y(\d+)\..*/;      
      $.getJSON("models/list.json", function(files) {

        files.forEach(function(file) {
          var key = Object.keys(file)[0];
          var match = myRegexp.exec(key);
          var X = match[1];
          var Y = match[2];
          var dx, dy;
          
          // load the tile
          var loader = new THREE.JSONLoader();
          loader.load( "models/" + key, function(geometry, mat){
            var material = new THREE.MeshFaceMaterial(mat);
            mesh = new THREE.Mesh(geometry, material);
            var hex  = 0xff0000;
            var bbox = new THREE.BoundingBoxHelper( mesh, hex );
            bbox.update();

            dx = bbox.box.max.x;
            dy = bbox.box.max.z;
            mesh.position.x = (X-121) * 200 - dx;
            mesh.position.z = (Y-115) * 200 - dy;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
          });

          // load the buildings


          file[key].forEach(function(subfile) {

            loader.load( "models/" + subfile, function(geometry, mat){
              var material = new THREE.MeshFaceMaterial(mat);
              mesh = new THREE.Mesh(geometry, material);
              mesh.position.x = (X-121) * 200 - dx;
              mesh.position.z = (Y-115) * 200 - dy;
              mesh.castShadow = true;
              mesh.receiveShadow = true;
              scene.add(mesh);
            })
          })
        });
      })

      // Create a camera, zoom it out from the model a bit, and add it to the scene.
      camera = new THREE.PerspectiveCamera( 30, WIDTH / HEIGHT, 1, 5000 );
      camera.position.set(-300, 80, -3);
      scene.add(camera);

      function moveLight() { 
        // Create a light, set its position, and add it to the scene.
        var date = new Date(2014, curMonth, 5, curHour, 0, 0);
        var lonLatBordeaux = [-0.6056232, 44.8272294];
        var sunPosition = getSunPosition(date, lonLatBordeaux[1], lonLatBordeaux[0]);
        var radius = 300;
        var lightX = radius * Math.cos(sunPosition.azimuth+3.14);
        var lightY = radius * Math.sin(sunPosition.azimuth+3.14);
        var lighZ = radius * Math.tan(sunPosition.altitude);
        console.log(lightX, lighZ, lightY);
        light.position.set(lightX, lighZ, lightY);
        pointer.position.set(lightX, lighZ, lightY);
      };

      var light = new THREE.DirectionalLight(0xffffff, 1);
      // light.lookAt([0,0,0]);
      light.castShadow = true;
      light.shadowDarkness = 0.6;
      light.shadowMapWidth = 2048;
      light.shadowMapHeight = 2048;
      scene.add(light);

      var radius = 10,
      segments = 16,
      rings = 16;
      var sphere = new THREE.SphereGeometry(radius,segments,rings);
      var pointer = new THREE.Mesh( sphere, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
      scene.add( pointer );
      moveLight();

      function dateUpdated() {
        $('.current-hour').text(curHour);
        moveLight();
      }

      $('.hour')
          .on('input', function () {
              curHour = $(this).val();
              dateUpdated();
          });
      $('.hour').val(String(curHour));

      $('.season')
          .on('change', function () {
              var isChecked = $(this).val();
              curMonth = isChecked ? seasonsMonth[1] : seasonsMonth[0];
              dateUpdated();
          });

      // Add OrbitControls so that we can pan around with the mouse.
      controls = new THREE.OrbitControls(camera, renderer.domElement);

    }


    // Renders the scene and updates the render as needed.
    function animate() {

      // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      requestAnimationFrame(animate);
      
      // Render the scene.
      renderer.render(scene, camera);
      controls.update();

    }

  </script>

</body>
</html>
